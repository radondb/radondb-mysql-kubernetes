diff --git a/DEPLOY.md b/DEPLOY.md
new file mode 100644
index 0000000..d1eb8a0
--- /dev/null
+++ b/DEPLOY.md
@@ -0,0 +1,106 @@
+# mysql-operator
+
+## Quickstart
+
+Install the operator named `test`:
+
+```shell
+helm install test https://github.com/radondb/radondb-mysql-kubernetes/releases/latest/download/mysql-operator.tgz
+```
+
+Then install the cluster named `sample`:
+```shell
+kubectl create -f config/samples/backup_secret.yaml
+```
+
+```shell
+kubectl apply -f config/samples/mysql_v1alpha1_cluster.yaml     
+```
+## backup
+After run cluster success
+```shell
+kubectl apply -f config/samples/samples/mysql_v1alpha1_mysqlbackup.yaml
+```
+
+## Uninstall
+
+Uninstall the cluster named `sample`:
+
+```shell
+kubectl delete clusters.mysql.radondb.io sample
+```
+
+Uninstall the operator name `test`:
+
+```shell
+helm uninstall test
+```
+
+Uninstall the crd:
+
+```shell
+kubectl delete customresourcedefinitions.apiextensions.k8s.io clusters.mysql.radondb.io
+```
+
+## configure backup
+
+add the secret file
+```yaml
+kind: Secret
+apiVersion: v1
+metadata:
+  name: sample-backup-secret
+  namespace: default
+data:
+  s3-endpoint: aHR0cDovL3MzLnNoMWEucWluZ3N0b3IuY29t
+  s3-access-key: SEdKWldXVllLSENISllFRERKSUc=
+  s3-secret-key: TU44TkNUdDJLdHlZREROTTc5cTNwdkxtNTlteE01blRaZlRQMWxoag==
+  s3-bucket: bGFsYS1teXNxbA==
+type: Opaque
+
+```
+s3-xxxx value is encode by base64, you can get like that
+```shell
+echo -n "hello"|base64
+```
+then, create the secret in k8s.
+```
+kubectl create -f config/samples/backup_secret.yaml
+```
+
+now create mysqlbackup yaml file mysql_v1_mysqlbackup.yaml like this:
+
+```yaml
+apiVersion: mysql.radondb.io/v1
+kind: MysqlBackup
+metadata:
+  name: mysqlbackup-sample1
+spec:
+  # Add fields here
+  hostname: sample-mysql-0
+  clustname: sample
+
+
+
+```
+
+## start backup
+After cluster has started, if you want backup:
+```shell
+ kubectl apply -f config/samples/mysql_v1_mysqlbackup.yaml
+ ```
+
+ ## build your own image
+ such as :
+ ```
+ docker build -f Dockerfile.sidecar -t  acekingke/sidecar:v01 . && docker push acekingke/sidecar:v01
+ docker build -t acekingke/controller:v01 . && docker push acekingke/controller:v01
+ ```
+ you can replace acekingke/sidecar:v01 with your own tag
+
+ ## deploy your own manager
+```shell
+make manifests
+make install 
+make deploy  IMG=acekingke/controller:v01 KUSTOMIZE=~/radondb-mysql-kubernetes/bin/kustomize 
+```
diff --git a/Dockerfile b/Dockerfile
index 5f63041..edafe9c 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -15,6 +15,7 @@ COPY cmd/manager/main.go cmd/manager/main.go
 COPY api/ api/
 COPY cluster/ cluster/
 COPY controllers/ controllers/
+COPY mysqlbackup/ mysqlbackup/
 COPY internal/ internal/
 COPY utils/ utils/
 
diff --git a/Dockerfile.sidecar b/Dockerfile.sidecar
index a29933a..da18a02 100644
--- a/Dockerfile.sidecar
+++ b/Dockerfile.sidecar
@@ -2,12 +2,14 @@
 #  Build Sidecar
 ###############################################################################
 # Build the manager binary
-FROM golang:1.16 as builder
+FROM golang:1.15 as builder
 
 WORKDIR /workspace
 # Copy the Go Modules manifests
 COPY go.mod go.mod
 COPY go.sum go.sum
+
+
 # cache deps before building and copying source so that we don't need to re-download as much
 # and so that source changes don't invalidate our downloaded layer
 RUN go env -w GOPROXY=https://goproxy.cn,direct; \
@@ -19,17 +21,39 @@ COPY sidecar/ sidecar/
 COPY utils/ utils/
 
 # Build
-RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -a -o bin/sidecar cmd/sidecar/main.go
+RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 GO111MODULE=on go build -a -o bin/sidecar cmd/sidecar/main.go
 
 ###############################################################################
 #  Docker image for Sidecar
 ###############################################################################
-FROM alpine:3.13
+FROM ubuntu:focal
 
-# Create a group and user
-RUN addgroup -g 1001 mysql && adduser -u 1001 -g 1001 -S mysql
+RUN set -ex; \
+    groupadd --gid 1001 --system mysql; \
+    useradd \
+    --uid 1001 \
+    --system \
+    --home-dir /var/lib/mysql \
+    --no-create-home \
+    --gid mysql \
+    mysql;
 
+ENV PS_VERSION 5.7.33-36-1
+ENV OS_VER focal
+ENV FULL_PERCONA_VERSION "$PS_VERSION.$OS_VER"
+
+ARG XTRABACKUP_PKG=percona-xtrabackup-24
+RUN set -ex; \
+    apt-get update; \
+    apt-get install -y --no-install-recommends gnupg2 wget lsb-release curl; \
+    wget -P /tmp --no-check-certificate https://repo.percona.com/apt/percona-release_latest.$(lsb_release -sc)_all.deb; \
+    dpkg -i /tmp/percona-release_latest.$(lsb_release -sc)_all.deb; \
+    apt-get update; \
+    apt-get install -y --no-install-recommends ${XTRABACKUP_PKG}
 WORKDIR /
 COPY --from=builder /workspace/bin/sidecar /usr/local/bin/sidecar
-
+COPY ./hack/restore.sh /restore.sh
+RUN set -ex; \
+    chmod +x /restore.sh; \
+    chown mysql.mysql /restore.sh
 ENTRYPOINT ["sidecar"]
diff --git a/PROJECT b/PROJECT
index 06099a4..9b2ab4e 100644
--- a/PROJECT
+++ b/PROJECT
@@ -18,4 +18,13 @@ resources:
   group: mysql
   kind: Status
   version: v1alpha1
+- api:
+    crdVersion: v1
+    namespaced: true
+  controller: true
+  domain: radondb.io
+  group: mysql
+  kind: MysqlBackup
+  path: github.com/radondb/radondb-mysql-kubernetes/api/v1alpha1
+  version: v1
 version: "3"
diff --git a/api/v1alpha1/cluster_types.go b/api/v1alpha1/cluster_types.go
index 497b624..8f788fd 100644
--- a/api/v1alpha1/cluster_types.go
+++ b/api/v1alpha1/cluster_types.go
@@ -66,6 +66,15 @@ type ClusterSpec struct {
 	// +optional
 	// +kubebuilder:default:={enabled: true, accessModes: {"ReadWriteOnce"}, size: "10Gi"}
 	Persistence Persistence `json:"persistence,omitempty"`
+
+	// Represents the name of the secret that contains credentials to connect to
+	// the storage provider to store backups.
+	// +optional
+	BackupSecretName string `json:"backupSecretName,omitempty"`
+
+	// Represents the name of the cluster restore from backup path
+	// +optional
+	RestoreFrom string `json:"restoreFrom,omitempty"`
 }
 
 // MysqlOpts defines the options of MySQL container.
diff --git a/api/v1alpha1/mysqlbackup_types.go b/api/v1alpha1/mysqlbackup_types.go
new file mode 100644
index 0000000..c3f875f
--- /dev/null
+++ b/api/v1alpha1/mysqlbackup_types.go
@@ -0,0 +1,97 @@
+/*
+Copyright 2021 zhyass.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package v1alpha1
+
+import (
+	corev1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+)
+
+// EDIT THIS FILE!  THIS IS SCAFFOLDING FOR YOU TO OWN!
+// NOTE: json tags are required.  Any new fields you add must have json tags for the fields to be serialized.
+
+// MysqlBackupSpec defines the desired state of MysqlBackup
+type MysqlBackupSpec struct {
+	// INSERT ADDITIONAL SPEC FIELDS - desired state of cluster
+	// Important: Run "make" to regenerate code after modifying this file
+
+	// Foo is an example field of MysqlBackup. Edit mysqlbackup_types.go to remove/update
+
+	// HostName represents the host for which to take backup
+	HostName    string `json:"hostname"`
+	ClusterName string `json:"clustname"`
+}
+
+// MysqlBackupStatus defines the observed state of MysqlBackup
+type MysqlBackupStatus struct {
+	// INSERT ADDITIONAL STATUS FIELD - define observed state of cluster
+	// Important: Run "make" to regenerate code after modifying this file
+	Completed bool `json:"completed,omitempty"`
+
+	// Conditions represents the backup resource conditions list.
+	Conditions []BackupCondition `json:"conditions,omitempty"`
+}
+
+//+kubebuilder:object:root=true
+//+kubebuilder:subresource:status
+
+// MysqlBackup is the Schema for the mysqlbackups API
+type MysqlBackup struct {
+	metav1.TypeMeta   `json:",inline"`
+	metav1.ObjectMeta `json:"metadata,omitempty"`
+
+	Spec   MysqlBackupSpec   `json:"spec,omitempty"`
+	Status MysqlBackupStatus `json:"status,omitempty"`
+}
+
+// BackupCondition defines condition struct for backup resource
+type BackupCondition struct {
+	// type of cluster condition, values in (\"Ready\")
+	Type BackupConditionType `json:"type"`
+	// Status of the condition, one of (\"True\", \"False\", \"Unknown\")
+	Status corev1.ConditionStatus `json:"status"`
+
+	// LastTransitionTime
+	LastTransitionTime metav1.Time `json:"lastTransitionTime"`
+	// Reason
+	Reason string `json:"reason"`
+	// Message
+	Message string `json:"message"`
+}
+
+// BackupConditionType defines condition types of a backup resources
+type BackupConditionType string
+
+const (
+	// BackupComplete means the backup has finished his execution
+	BackupComplete BackupConditionType = "Complete"
+	// BackupFailed means backup has failed
+	BackupFailed BackupConditionType = "Failed"
+)
+
+//+kubebuilder:object:root=true
+
+// MysqlBackupList contains a list of MysqlBackup
+type MysqlBackupList struct {
+	metav1.TypeMeta `json:",inline"`
+	metav1.ListMeta `json:"metadata,omitempty"`
+	Items           []MysqlBackup `json:"items"`
+}
+
+func init() {
+	SchemeBuilder.Register(&MysqlBackup{}, &MysqlBackupList{})
+}
diff --git a/api/v1alpha1/zz_generated.deepcopy.go b/api/v1alpha1/zz_generated.deepcopy.go
index 57887b8..b314907 100644
--- a/api/v1alpha1/zz_generated.deepcopy.go
+++ b/api/v1alpha1/zz_generated.deepcopy.go
@@ -25,6 +25,22 @@ import (
 	runtime "k8s.io/apimachinery/pkg/runtime"
 )
 
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *BackupCondition) DeepCopyInto(out *BackupCondition) {
+	*out = *in
+	in.LastTransitionTime.DeepCopyInto(&out.LastTransitionTime)
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BackupCondition.
+func (in *BackupCondition) DeepCopy() *BackupCondition {
+	if in == nil {
+		return nil
+	}
+	out := new(BackupCondition)
+	in.DeepCopyInto(out)
+	return out
+}
+
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *Cluster) DeepCopyInto(out *Cluster) {
 	*out = *in
@@ -170,6 +186,102 @@ func (in *MetricsOpts) DeepCopy() *MetricsOpts {
 	return out
 }
 
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *MysqlBackup) DeepCopyInto(out *MysqlBackup) {
+	*out = *in
+	out.TypeMeta = in.TypeMeta
+	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
+	out.Spec = in.Spec
+	in.Status.DeepCopyInto(&out.Status)
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MysqlBackup.
+func (in *MysqlBackup) DeepCopy() *MysqlBackup {
+	if in == nil {
+		return nil
+	}
+	out := new(MysqlBackup)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
+func (in *MysqlBackup) DeepCopyObject() runtime.Object {
+	if c := in.DeepCopy(); c != nil {
+		return c
+	}
+	return nil
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *MysqlBackupList) DeepCopyInto(out *MysqlBackupList) {
+	*out = *in
+	out.TypeMeta = in.TypeMeta
+	in.ListMeta.DeepCopyInto(&out.ListMeta)
+	if in.Items != nil {
+		in, out := &in.Items, &out.Items
+		*out = make([]MysqlBackup, len(*in))
+		for i := range *in {
+			(*in)[i].DeepCopyInto(&(*out)[i])
+		}
+	}
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MysqlBackupList.
+func (in *MysqlBackupList) DeepCopy() *MysqlBackupList {
+	if in == nil {
+		return nil
+	}
+	out := new(MysqlBackupList)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
+func (in *MysqlBackupList) DeepCopyObject() runtime.Object {
+	if c := in.DeepCopy(); c != nil {
+		return c
+	}
+	return nil
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *MysqlBackupSpec) DeepCopyInto(out *MysqlBackupSpec) {
+	*out = *in
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MysqlBackupSpec.
+func (in *MysqlBackupSpec) DeepCopy() *MysqlBackupSpec {
+	if in == nil {
+		return nil
+	}
+	out := new(MysqlBackupSpec)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *MysqlBackupStatus) DeepCopyInto(out *MysqlBackupStatus) {
+	*out = *in
+	if in.Conditions != nil {
+		in, out := &in.Conditions, &out.Conditions
+		*out = make([]BackupCondition, len(*in))
+		for i := range *in {
+			(*in)[i].DeepCopyInto(&(*out)[i])
+		}
+	}
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MysqlBackupStatus.
+func (in *MysqlBackupStatus) DeepCopy() *MysqlBackupStatus {
+	if in == nil {
+		return nil
+	}
+	out := new(MysqlBackupStatus)
+	in.DeepCopyInto(out)
+	return out
+}
+
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in MysqlConf) DeepCopyInto(out *MysqlConf) {
 	{
diff --git a/cluster/cluster.go b/cluster/cluster.go
index 08b30e8..eebe41d 100644
--- a/cluster/cluster.go
+++ b/cluster/cluster.go
@@ -248,6 +248,8 @@ func (c *Cluster) GetNameForResource(name utils.ResourceName) string {
 		return fmt.Sprintf("%s-follower", c.Name)
 	case utils.Secret:
 		return fmt.Sprintf("%s-secret", c.Name)
+	case utils.BackupSecret:
+		return fmt.Sprintf("%s-backup-secret", c.Name)
 	default:
 		return c.Name
 	}
diff --git a/cluster/container/backup.go b/cluster/container/backup.go
new file mode 100644
index 0000000..1964845
--- /dev/null
+++ b/cluster/container/backup.go
@@ -0,0 +1,104 @@
+package container
+
+import (
+	corev1 "k8s.io/api/core/v1"
+	"k8s.io/apimachinery/pkg/util/intstr"
+
+	"github.com/radondb/radondb-mysql-kubernetes/cluster"
+	"github.com/radondb/radondb-mysql-kubernetes/utils"
+)
+
+type backupSidecar struct {
+	*cluster.Cluster
+
+	name string
+}
+
+func (c *backupSidecar) getName() string {
+	return c.name
+}
+
+func (c *backupSidecar) getImage() string {
+	return c.Spec.PodSpec.SidecarImage
+}
+
+func (c *backupSidecar) getCommand() []string {
+	return []string{"sidecar", "http"}
+}
+
+func (c *backupSidecar) getEnvVars() []corev1.EnvVar {
+	sctName := c.GetNameForResource(utils.BackupSecret)
+
+	envs := []corev1.EnvVar{
+
+		{
+			Name:  "NAMESPACE",
+			Value: c.Namespace,
+		},
+		{
+			Name:  "SERVICE_NAME",
+			Value: c.GetNameForResource(utils.HeadlessSVC),
+		},
+		getEnvVarFromSecret(sctName, "S3_ENDPOINT", "s3-endpoint", false),
+		getEnvVarFromSecret(sctName, "S3_ACCESSKEY", "s3-access-key", true),
+		getEnvVarFromSecret(sctName, "S3_SECRETKEY", "s3-secret-key", true),
+		getEnvVarFromSecret(sctName, "S3_BUCKET", "s3-bucket", true),
+	}
+
+	return envs
+}
+
+func (c *backupSidecar) getLifecycle() *corev1.Lifecycle {
+	return nil
+}
+
+func (c *backupSidecar) getResources() corev1.ResourceRequirements {
+	return c.Spec.PodSpec.Resources
+}
+
+func (c *backupSidecar) getPorts() []corev1.ContainerPort {
+	return []corev1.ContainerPort{
+		{
+			Name:          utils.XBackupPortName,
+			ContainerPort: utils.XBackupPort,
+		},
+	}
+}
+
+func (c *backupSidecar) getLivenessProbe() *corev1.Probe {
+	return nil
+}
+
+func (c *backupSidecar) getReadinessProbe() *corev1.Probe {
+	return &corev1.Probe{
+		Handler: corev1.Handler{
+			HTTPGet: &corev1.HTTPGetAction{
+				Path: "/health",
+				Port: intstr.FromInt(utils.XBackupPort),
+			},
+		},
+		InitialDelaySeconds: 5,
+		TimeoutSeconds:      1,
+		PeriodSeconds:       10,
+		SuccessThreshold:    1,
+		FailureThreshold:    3,
+	}
+}
+
+func (c *backupSidecar) getVolumeMounts() []corev1.VolumeMount {
+	return []corev1.VolumeMount{
+		{
+			Name:      utils.ConfVolumeName,
+			MountPath: utils.ConfVolumeMountPath,
+		},
+		{
+			Name:      utils.DataVolumeName,
+			MountPath: utils.DataVolumeMountPath,
+		},
+		{
+			Name:      utils.LogsVolumeName,
+			MountPath: utils.LogsVolumeMountPath,
+		},
+	}
+
+}
diff --git a/cluster/container/container.go b/cluster/container/container.go
index 3d14021..0dbeb0f 100644
--- a/cluster/container/container.go
+++ b/cluster/container/container.go
@@ -55,6 +55,8 @@ func EnsureContainer(name string, c *cluster.Cluster) corev1.Container {
 		ctr = &slowLog{c, name}
 	case utils.ContainerAuditLogName:
 		ctr = &auditLog{c, name}
+	case utils.ContainerBackupName:
+		ctr = &backupSidecar{c, name}
 	}
 
 	return corev1.Container{
diff --git a/cluster/container/init_sidecar.go b/cluster/container/init_sidecar.go
index 103d640..b1a0595 100644
--- a/cluster/container/init_sidecar.go
+++ b/cluster/container/init_sidecar.go
@@ -51,6 +51,7 @@ func (c *initSidecar) getCommand() []string {
 // getEnvVars get the container env.
 func (c *initSidecar) getEnvVars() []corev1.EnvVar {
 	sctName := c.GetNameForResource(utils.Secret)
+	sctNamebackup := c.GetNameForResource(utils.BackupSecret)
 	envs := []corev1.EnvVar{
 		{
 			Name: "POD_HOSTNAME",
@@ -81,6 +82,16 @@ func (c *initSidecar) getEnvVars() []corev1.EnvVar {
 			Name:  "MY_MYSQL_VERSION",
 			Value: c.GetMySQLVersion(),
 		},
+		{
+			Name:  "RESTORE_FROM",
+			Value: c.Spec.RestoreFrom,
+		},
+
+		getEnvVarFromSecret(sctNamebackup, "S3_ENDPOINT", "s3-endpoint", false),
+		getEnvVarFromSecret(sctNamebackup, "S3_ACCESSKEY", "s3-access-key", true),
+		getEnvVarFromSecret(sctNamebackup, "S3_SECRETKEY", "s3-secret-key", true),
+		getEnvVarFromSecret(sctNamebackup, "S3_BUCKET", "s3-bucket", true),
+
 		getEnvVarFromSecret(sctName, "MYSQL_ROOT_PASSWORD", "root-password", false),
 		getEnvVarFromSecret(sctName, "MYSQL_REPL_USER", "replication-user", true),
 		getEnvVarFromSecret(sctName, "MYSQL_REPL_PASSWORD", "replication-password", true),
diff --git a/cluster/syncer/statefulset.go b/cluster/syncer/statefulset.go
index fbcc3cf..bc90552 100644
--- a/cluster/syncer/statefulset.go
+++ b/cluster/syncer/statefulset.go
@@ -90,7 +90,8 @@ func ensurePodSpec(c *cluster.Cluster) corev1.PodSpec {
 
 	mysql := container.EnsureContainer(utils.ContainerMysqlName, c)
 	xenon := container.EnsureContainer(utils.ContainerXenonName, c)
-	containers := []corev1.Container{mysql, xenon}
+	backup := container.EnsureContainer(utils.ContainerBackupName, c)
+	containers := []corev1.Container{mysql, xenon, backup}
 	if c.Spec.MetricsOpts.Enabled {
 		containers = append(containers, container.EnsureContainer(utils.ContainerMetricsName, c))
 	}
diff --git a/cmd/manager/main.go b/cmd/manager/main.go
index 49f1e24..c7301c6 100644
--- a/cmd/manager/main.go
+++ b/cmd/manager/main.go
@@ -94,6 +94,15 @@ func main() {
 		setupLog.Error(err, "unable to create controller", "controller", "Status")
 		os.Exit(1)
 	}
+	if err = (&controllers.MysqlBackupReconciler{
+		Client:   mgr.GetClient(),
+		Scheme:   mgr.GetScheme(),
+		Recorder: mgr.GetEventRecorderFor("controller.mysqlBackup"),
+		//Opt:      options.GetOptions(),
+	}).SetupWithManager(mgr); err != nil {
+		setupLog.Error(err, "unable to create controller", "controller", "MysqlBackup")
+		os.Exit(1)
+	}
 	//+kubebuilder:scaffold:builder
 
 	if err := mgr.AddHealthzCheck("healthz", healthz.Ping); err != nil {
diff --git a/cmd/sidecar/main.go b/cmd/sidecar/main.go
index 1e91a86..8fcf4e1 100644
--- a/cmd/sidecar/main.go
+++ b/cmd/sidecar/main.go
@@ -17,6 +17,7 @@ limitations under the License.
 package main
 
 import (
+	"fmt"
 	"os"
 
 	"github.com/spf13/cobra"
@@ -51,10 +52,61 @@ func main() {
 	logf.SetLogger(zap.New(zap.UseDevMode(true)))
 
 	cfg := sidecar.NewConfig()
-
+	stop := make(chan struct{})
 	initCmd := sidecar.NewInitCommand(cfg)
 	cmd.AddCommand(initCmd)
+	takeBackupCmd := &cobra.Command{
+		Use:   "backup",
+		Short: "Take a backup from node and push it to rclone path.",
+		Args: func(cmd *cobra.Command, args []string) error {
+			if len(args) != 1 {
+				return fmt.Errorf("require two arguments. source host and destination bucket")
+			}
+			return nil
+		},
+		Run: func(cmd *cobra.Command, args []string) {
+			//TODO: make backup cmd
+			err := sidecar.RunTakeBackupCommand(cfg, args[0])
+			if err != nil {
+				log.Error(err, "take backup command failed")
+				os.Exit(1)
+
+			}
+		},
+	}
+	cmd.AddCommand(takeBackupCmd)
+	httpCmd := &cobra.Command{
+		Use:   "http",
+		Short: "start http server",
+
+		Run: func(cmd *cobra.Command, args []string) {
+			//TODO: make backup cmd
 
+			if err := sidecar.RunHttpServer(cfg, stop); err != nil {
+				log.Error(err, "run command failed")
+				os.Exit(1)
+			}
+		},
+	}
+	cmd.AddCommand(httpCmd)
+	reqBackupCmd := &cobra.Command{
+		Use:   "request_a_backup",
+		Short: "start request a backup",
+		Args: func(cmd *cobra.Command, args []string) error {
+			if len(args) != 1 {
+				return fmt.Errorf("require one arguments. ")
+			}
+			return nil
+		},
+		Run: func(cmd *cobra.Command, args []string) {
+			//TODO request a backup
+			if err := sidecar.RunRequestBackup(cfg, args[0]); err != nil {
+				log.Error(err, "run command failed")
+				os.Exit(1)
+			}
+		},
+	}
+	cmd.AddCommand(reqBackupCmd)
 	if err := cmd.Execute(); err != nil {
 		log.Error(err, "failed to execute command", "cmd", cmd)
 		os.Exit(1)
diff --git a/config/crd/bases/mysql.radondb.com_clusters.yaml b/config/crd/bases/mysql.radondb.com_clusters.yaml
index 05f40f7..1d07b1d 100644
--- a/config/crd/bases/mysql.radondb.com_clusters.yaml
+++ b/config/crd/bases/mysql.radondb.com_clusters.yaml
@@ -50,6 +50,10 @@ spec:
           spec:
             description: ClusterSpec defines the desired state of Cluster
             properties:
+              backupSecretName:
+                description: Represents the name of the secret that contains credentials
+                  to connect to the storage provider to store backups.
+                type: string
               metricsOpts:
                 default:
                   enabled: false
@@ -132,10 +136,7 @@ spec:
                     type: boolean
                   mysqlConf:
                     additionalProperties:
-                      anyOf:
-                      - type: integer
-                      - type: string
-                      x-kubernetes-int-or-string: true
+                      type: string
                     description: A map[string]string that will be passed to my.cnf
                       file.
                     type: object
@@ -969,6 +970,10 @@ spec:
                 - 5
                 format: int32
                 type: integer
+              restoreFrom:
+                description: Represents the name of the cluster restore from backup
+                  path
+                type: string
               xenonOpts:
                 default:
                   admitDefeatHearbeatCount: 5
diff --git a/config/crd/bases/mysql.radondb.com_mysqlbackups.yaml b/config/crd/bases/mysql.radondb.com_mysqlbackups.yaml
new file mode 100644
index 0000000..f327d61
--- /dev/null
+++ b/config/crd/bases/mysql.radondb.com_mysqlbackups.yaml
@@ -0,0 +1,99 @@
+
+---
+apiVersion: apiextensions.k8s.io/v1
+kind: CustomResourceDefinition
+metadata:
+  annotations:
+    controller-gen.kubebuilder.io/version: v0.4.1
+  creationTimestamp: null
+  name: mysqlbackups.mysql.radondb.com
+spec:
+  group: mysql.radondb.com
+  names:
+    kind: MysqlBackup
+    listKind: MysqlBackupList
+    plural: mysqlbackups
+    singular: mysqlbackup
+  scope: Namespaced
+  versions:
+  - name: v1alpha1
+    schema:
+      openAPIV3Schema:
+        description: MysqlBackup is the Schema for the mysqlbackups API
+        properties:
+          apiVersion:
+            description: 'APIVersion defines the versioned schema of this representation
+              of an object. Servers should convert recognized schemas to the latest
+              internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
+            type: string
+          kind:
+            description: 'Kind is a string value representing the REST resource this
+              object represents. Servers may infer this from the endpoint the client
+              submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
+            type: string
+          metadata:
+            type: object
+          spec:
+            description: MysqlBackupSpec defines the desired state of MysqlBackup
+            properties:
+              clustname:
+                type: string
+              hostname:
+                description: HostName represents the host for which to take backup
+                type: string
+            required:
+            - clustname
+            - hostname
+            type: object
+          status:
+            description: MysqlBackupStatus defines the observed state of MysqlBackup
+            properties:
+              completed:
+                description: 'INSERT ADDITIONAL STATUS FIELD - define observed state
+                  of cluster Important: Run "make" to regenerate code after modifying
+                  this file'
+                type: boolean
+              conditions:
+                description: Conditions represents the backup resource conditions
+                  list.
+                items:
+                  description: BackupCondition defines condition struct for backup
+                    resource
+                  properties:
+                    lastTransitionTime:
+                      description: LastTransitionTime
+                      format: date-time
+                      type: string
+                    message:
+                      description: Message
+                      type: string
+                    reason:
+                      description: Reason
+                      type: string
+                    status:
+                      description: Status of the condition, one of (\"True\", \"False\",
+                        \"Unknown\")
+                      type: string
+                    type:
+                      description: type of cluster condition, values in (\"Ready\")
+                      type: string
+                  required:
+                  - lastTransitionTime
+                  - message
+                  - reason
+                  - status
+                  - type
+                  type: object
+                type: array
+            type: object
+        type: object
+    served: true
+    storage: true
+    subresources:
+      status: {}
+status:
+  acceptedNames:
+    kind: ""
+    plural: ""
+  conditions: []
+  storedVersions: []
diff --git a/config/crd/kustomization.yaml b/config/crd/kustomization.yaml
index 3d34717..a13ee00 100644
--- a/config/crd/kustomization.yaml
+++ b/config/crd/kustomization.yaml
@@ -3,6 +3,7 @@
 # It should be run by config/default
 resources:
 - bases/mysql.radondb.com_clusters.yaml
+- bases/mysql.radondb.com_mysqlbackups.yaml
 #+kubebuilder:scaffold:crdkustomizeresource
 
 patchesStrategicMerge:
diff --git a/config/manager/kustomization.yaml b/config/manager/kustomization.yaml
index 2bcd3ee..600b2f9 100644
--- a/config/manager/kustomization.yaml
+++ b/config/manager/kustomization.yaml
@@ -5,6 +5,12 @@ generatorOptions:
   disableNameSuffixHash: true
 
 configMapGenerator:
-- name: manager-config
-  files:
+- files:
   - controller_manager_config.yaml
+  name: manager-config
+apiVersion: kustomize.config.k8s.io/v1beta1
+kind: Kustomization
+images:
+- name: controller
+  newName: acekingke/controller
+  newTag: v01
diff --git a/config/rbac/mysqlbackup_editor_role.yaml b/config/rbac/mysqlbackup_editor_role.yaml
new file mode 100644
index 0000000..9c394e4
--- /dev/null
+++ b/config/rbac/mysqlbackup_editor_role.yaml
@@ -0,0 +1,24 @@
+# permissions for end users to edit mysqlbackups.
+apiVersion: rbac.authorization.k8s.io/v1
+kind: ClusterRole
+metadata:
+  name: mysqlbackup-editor-role
+rules:
+- apiGroups:
+  - mysql.radondb.com
+  resources:
+  - mysqlbackups
+  verbs:
+  - create
+  - delete
+  - get
+  - list
+  - patch
+  - update
+  - watch
+- apiGroups:
+  - mysql.radondb.com
+  resources:
+  - mysqlbackups/status
+  verbs:
+  - get
diff --git a/config/rbac/mysqlbackup_viewer_role.yaml b/config/rbac/mysqlbackup_viewer_role.yaml
new file mode 100644
index 0000000..3a5961d
--- /dev/null
+++ b/config/rbac/mysqlbackup_viewer_role.yaml
@@ -0,0 +1,20 @@
+# permissions for end users to view mysqlbackups.
+apiVersion: rbac.authorization.k8s.io/v1
+kind: ClusterRole
+metadata:
+  name: mysqlbackup-viewer-role
+rules:
+- apiGroups:
+  - mysql.radondb.io
+  resources:
+  - mysqlbackups
+  verbs:
+  - get
+  - list
+  - watch
+- apiGroups:
+  - mysql.radondb.io
+  resources:
+  - mysqlbackups/status
+  verbs:
+  - get
diff --git a/config/rbac/role.yaml b/config/rbac/role.yaml
index 46a1db3..a8d0705 100644
--- a/config/rbac/role.yaml
+++ b/config/rbac/role.yaml
@@ -18,6 +18,18 @@ rules:
   - patch
   - update
   - watch
+- apiGroups:
+  - batch
+  resources:
+  - jobs
+  verbs:
+  - create
+  - delete
+  - get
+  - list
+  - patch
+  - update
+  - watch
 - apiGroups:
   - coordination.k8s.io
   resources:
@@ -96,6 +108,32 @@ rules:
   - get
   - patch
   - update
+- apiGroups:
+  - mysql.radondb.com
+  resources:
+  - mysqlbackups
+  verbs:
+  - create
+  - delete
+  - get
+  - list
+  - patch
+  - update
+  - watch
+- apiGroups:
+  - mysql.radondb.com
+  resources:
+  - mysqlbackups/finalizers
+  verbs:
+  - update
+- apiGroups:
+  - mysql.radondb.com
+  resources:
+  - mysqlbackups/status
+  verbs:
+  - get
+  - patch
+  - update
 - apiGroups:
   - rbac.authorization.k8s.io
   resources:
diff --git a/config/samples/backup_secret.yaml b/config/samples/backup_secret.yaml
new file mode 100644
index 0000000..4c4efa5
--- /dev/null
+++ b/config/samples/backup_secret.yaml
@@ -0,0 +1,11 @@
+kind: Secret
+apiVersion: v1
+metadata:
+  name: sample-backup-secret
+  namespace: default
+data:
+  s3-endpoint: aHR0cDovL3MzLnNoMWEucWluZ3N0b3IuY29t
+  s3-access-key: SEdKWldXVllLSENISllFRERKSUc=
+  s3-secret-key: TU44TkNUdDJLdHlZREROTTc5cTNwdkxtNTlteE01blRaZlRQMWxoag==
+  s3-bucket: bGFsYS1teXNxbA==
+type: Opaque
diff --git a/config/samples/mysql_v1alpha1_cluster.yaml b/config/samples/mysql_v1alpha1_cluster.yaml
index 6cb69d0..14e96b3 100644
--- a/config/samples/mysql_v1alpha1_cluster.yaml
+++ b/config/samples/mysql_v1alpha1_cluster.yaml
@@ -5,7 +5,8 @@ metadata:
 spec:
   replicas: 3
   mysqlVersion: "5.7"
-
+  backupSecretName: backup-secret
+  restoreFrom: "backup_202162874118"
   mysqlOpts:
     rootPassword: ""
     user: qc_usr
@@ -53,8 +54,8 @@ spec:
         memory: 128Mi
 
   podSpec:
-    imagePullPolicy: IfNotPresent
-    sidecarImage: zhyass/sidecar:0.1
+    imagePullPolicy: Always
+    sidecarImage: acekingke/sidecar:v01
     busyboxImage: busybox:1.32
 
     slowLogTail: false
diff --git a/config/samples/mysql_v1alpha1_mysqlbackup.yaml b/config/samples/mysql_v1alpha1_mysqlbackup.yaml
new file mode 100644
index 0000000..e3c743d
--- /dev/null
+++ b/config/samples/mysql_v1alpha1_mysqlbackup.yaml
@@ -0,0 +1,10 @@
+apiVersion: mysql.radondb.com/v1alpha1
+kind: MysqlBackup
+metadata:
+  name: mysqlbackup-sample1
+spec:
+  # Add fields here
+  hostname: sample-mysql-0
+  clustname: sample
+
+
diff --git a/controllers/mysqlbackup_controller.go b/controllers/mysqlbackup_controller.go
new file mode 100644
index 0000000..ff9c659
--- /dev/null
+++ b/controllers/mysqlbackup_controller.go
@@ -0,0 +1,134 @@
+/*
+Copyright 2021 zhyass.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package controllers
+
+import (
+	"context"
+	"fmt"
+	"reflect"
+
+	"github.com/go-logr/logr"
+	"github.com/presslabs/controller-util/syncer"
+	apiv1alpha1 "github.com/radondb/radondb-mysql-kubernetes/api/v1alpha1"
+	"github.com/radondb/radondb-mysql-kubernetes/mysqlbackup"
+	backupSyncer "github.com/radondb/radondb-mysql-kubernetes/mysqlbackup/syncer"
+	"k8s.io/apimachinery/pkg/api/errors"
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/client-go/tools/record"
+	ctrl "sigs.k8s.io/controller-runtime"
+	"sigs.k8s.io/controller-runtime/pkg/client"
+	"sigs.k8s.io/controller-runtime/pkg/log"
+	"sigs.k8s.io/controller-runtime/pkg/reconcile"
+)
+
+// MysqlBackupReconciler reconciles a MysqlBackup object
+type MysqlBackupReconciler struct {
+	client.Client
+	Log      logr.Logger
+	Scheme   *runtime.Scheme
+	Recorder record.EventRecorder
+	//Opt      *options.Options
+}
+
+//+kubebuilder:rbac:groups=mysql.radondb.com,resources=mysqlbackups,verbs=get;list;watch;create;update;patch;delete
+//+kubebuilder:rbac:groups=batch,resources=jobs,verbs=get;list;watch;create;update;patch;delete
+//+kubebuilder:rbac:groups=core,resources=serviceaccounts,verbs=get;list;watch;create;update
+//+kubebuilder:rbac:groups=mysql.radondb.com,resources=mysqlbackups/status,verbs=get;update;patch
+//+kubebuilder:rbac:groups=mysql.radondb.com,resources=mysqlbackups/finalizers,verbs=update
+
+// Reconcile is part of the main kubernetes reconciliation loop which aims to
+// move the current state of the cluster closer to the desired state.
+// TODO(user): Modify the Reconcile function to compare the state specified by
+// the MysqlBackup object against the actual cluster state, and then
+// perform operations to make the cluster state reflect the state specified by
+// the user.
+//
+// For more details, check Reconcile and its Result here:
+// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.7.2/pkg/reconcile
+func (r *MysqlBackupReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
+	log := log.FromContext(ctx).WithName("controllers").WithName("MysqlBackup")
+
+	// your logic here
+	// Fetch the MysqlBackup instance
+	backup := mysqlbackup.New(&apiv1alpha1.MysqlBackup{})
+	err := r.Get(context.TODO(), req.NamespacedName, backup.Unwrap())
+	if err != nil {
+		if errors.IsNotFound(err) {
+			// Object not found, return.  Created objects are automatically garbage collected.
+			// For additional cleanup logic use finalizers.
+			return reconcile.Result{}, nil
+		}
+		// Error reading the object - requeue the request.
+		return reconcile.Result{}, err
+	}
+	// Set defaults on backup
+	r.Scheme.Default(backup.Unwrap())
+
+	// save the backup for later check for diff
+	savedBackup := backup.Unwrap().DeepCopy()
+	log.Info(fmt.Sprintf("saveBackup %v", savedBackup))
+	// cluster name should be specified for a backup
+	// if len(backup.Spec.ClusterName) == 0 {
+	// 	return reconcile.Result{}, fmt.Errorf("cluster name is not specified")
+	// }
+	//TODO:
+	syncers := []syncer.Interface{
+		backupSyncer.NewJobSyncer(r.Client, r.Scheme, backup),
+	}
+
+	if err = r.sync(context.TODO(), syncers); err != nil {
+		return reconcile.Result{}, err
+	}
+	if err = r.updateBackup(savedBackup, backup); err != nil {
+		return reconcile.Result{}, err
+	}
+
+	return ctrl.Result{}, nil
+}
+
+// SetupWithManager sets up the controller with the Manager.
+func (r *MysqlBackupReconciler) SetupWithManager(mgr ctrl.Manager) error {
+	return ctrl.NewControllerManagedBy(mgr).
+		For(&apiv1alpha1.MysqlBackup{}).
+		Complete(r)
+}
+func (r *MysqlBackupReconciler) updateBackup(savedBackup *apiv1alpha1.MysqlBackup, backup *mysqlbackup.MysqlBackup) error {
+	log := log.Log.WithName("controllers").WithName("MysqlBackup")
+	if !reflect.DeepEqual(savedBackup, backup.Unwrap()) {
+		if err := r.Update(context.TODO(), backup.Unwrap()); err != nil {
+			return err
+		}
+	}
+	if !reflect.DeepEqual(savedBackup.Status, backup.Unwrap().Status) {
+
+		log.Info("update backup object status")
+		if err := r.Status().Update(context.TODO(), backup.Unwrap()); err != nil {
+			log.Error(err, fmt.Sprintf("update status backup %s/%s", backup.Name, backup.Namespace),
+				"backupStatus", backup.Status)
+			return err
+		}
+	}
+	return nil
+}
+func (r *MysqlBackupReconciler) sync(ctx context.Context, syncers []syncer.Interface) error {
+	for _, s := range syncers {
+		if err := syncer.Sync(ctx, s, r.Recorder); err != nil {
+			return err
+		}
+	}
+	return nil
+}
diff --git a/go.mod b/go.mod
index ba31fc6..a1f43a2 100644
--- a/go.mod
+++ b/go.mod
@@ -5,6 +5,7 @@ go 1.16
 require (
 	github.com/blang/semver v3.5.1+incompatible
 	github.com/go-ini/ini v1.62.0
+	github.com/go-logr/logr v0.4.0
 	github.com/go-sql-driver/mysql v1.6.0
 	github.com/imdario/mergo v0.3.11
 	github.com/onsi/ginkgo v1.15.0
diff --git a/go.sum b/go.sum
index d1d18c2..5169dfc 100644
--- a/go.sum
+++ b/go.sum
@@ -86,6 +86,7 @@ github.com/coreos/pkg v0.0.0-20160727233714-3ac0863d7acf/go.mod h1:E3G3o1h8I7cfc
 github.com/coreos/pkg v0.0.0-20180928190104-399ea9e2e55f/go.mod h1:E3G3o1h8I7cfcXa63jLwjI0eiQQMgzzUDFVpN/nH/eA=
 github.com/cpuguy83/go-md2man/v2 v2.0.0/go.mod h1:maD7wRr/U5Z6m/iR4s+kqSMx2CaBsrgA7czyZG/E6dU=
 github.com/creack/pty v1.1.7/go.mod h1:lj5s0c3V2DBrqTV7llrYr5NG6My20zk30Fl46Y7DoTY=
+github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=
 github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
 github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
 github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
@@ -264,10 +265,12 @@ github.com/kr/logfmt v0.0.0-20140226030751-b84e30acd515/go.mod h1:+0opPa2QZZtGFB
 github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
 github.com/kr/pretty v0.2.0 h1:s5hAObm+yFO5uHYt5dYjxi2rXrsnmRpJx4OYvIWUaQs=
 github.com/kr/pretty v0.2.0/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=
+github.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=
 github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
 github.com/kr/pty v1.1.5/go.mod h1:9r2w37qlBe7rQ6e1fg1S/9xpWHSnaqNdHD3WcMdbPDA=
 github.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=
 github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
+github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
 github.com/magiconair/properties v1.8.1/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=
 github.com/mailru/easyjson v0.0.0-20190614124828-94de47d64c63/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=
 github.com/mailru/easyjson v0.0.0-20190626092158-b2ccc519800e/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=
@@ -401,6 +404,8 @@ github.com/urfave/cli v1.20.0/go.mod h1:70zkFmudgCuE/ngEzBv17Jvp/497gISqfk5gWijb
 github.com/xiang90/probing v0.0.0-20190116061207-43a291ad63a2/go.mod h1:UETIi67q53MR2AWcXfiuqkDkRtnGDLqkBTpCHuJHxtU=
 github.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
 github.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
+github.com/zhyass/mysql-operator v0.0.0-20210622095313-d12d0a2fbffe h1:ZJwXQjgeVYAtSNc5NgEYLocjGWe+1nw2FsTamUH3C+M=
+github.com/zhyass/mysql-operator v0.0.0-20210622095313-d12d0a2fbffe/go.mod h1:lFi1caFszT/F5D9RjP8dPytTcIJBV4n0r4QYYgyTURA=
 go.etcd.io/bbolt v1.3.2/go.mod h1:IbVyRI1SCnLcuJnV2u8VeU0CEYM7e686BmAb1XKL+uU=
 go.etcd.io/bbolt v1.3.3/go.mod h1:IbVyRI1SCnLcuJnV2u8VeU0CEYM7e686BmAb1XKL+uU=
 go.etcd.io/bbolt v1.3.5/go.mod h1:G5EMThwa9y8QZGBClrRx5EY+Yw9kAhnjy3bSjsnlVTQ=
@@ -498,6 +503,8 @@ golang.org/x/net v0.0.0-20201110031124-69a78807bb2b h1:uwuIcX0g4Yl1NC5XAz37xsr2l
 golang.org/x/net v0.0.0-20201110031124-69a78807bb2b/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
 golang.org/x/net v0.0.0-20201202161906-c7110b5ffcbb h1:eBmm0M9fYhWpKZLjQUUKka/LtIxf46G4fxeEz5KJr9U=
 golang.org/x/net v0.0.0-20201202161906-c7110b5ffcbb/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
+golang.org/x/net v0.0.0-20210226172049-e18ecbb05110 h1:qWPm9rbaAMKs8Bq/9LRpbMqxWRVUAQwMI9fVrssnTfw=
+golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
 golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=
 golang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
 golang.org/x/oauth2 v0.0.0-20190604053449-0f29369cfe45/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
@@ -548,10 +555,12 @@ golang.org/x/sys v0.0.0-20200615200032-f1bc736245b1/go.mod h1:h1NjWce9XRLGQEsW7w
 golang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/sys v0.0.0-20201112073958-5cba982894dd h1:5CtCZbICpIOFdgO940moixOPjc0178IU44m4EjOO5IY=
 golang.org/x/sys v0.0.0-20201112073958-5cba982894dd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
+golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/sys v0.0.0-20210112080510-489259a85091/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/sys v0.0.0-20210119212857-b64e53b001e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/sys v0.0.0-20210225134936-a50acf3fe073 h1:8qxJSnu+7dRq6upnbntrmriWByIakBuct5OM/MdQC1M=
 golang.org/x/sys v0.0.0-20210225134936-a50acf3fe073/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
+golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
 golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
 golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
 golang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
@@ -677,6 +686,7 @@ gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8
 gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
 gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15 h1:YR8cESwS4TdDjEe65xsg0ogRM/Nc3DYOhEAlW+xobZo=
 gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
+gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=
 gopkg.in/cheggaaa/pb.v1 v1.0.25/go.mod h1:V/YB90LKu/1FcN3WVnfiiE5oMCibMjukxqG/qStrOgw=
 gopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=
 gopkg.in/fsnotify.v1 v1.4.7/go.mod h1:Tz8NjZHkW78fSQdbUxIjBTcgA1z1m8ZHf0WmKUhAMys=
@@ -697,6 +707,8 @@ gopkg.in/yaml.v2 v2.2.5/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
 gopkg.in/yaml.v2 v2.2.8/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
 gopkg.in/yaml.v2 v2.3.0 h1:clyUAQHOM3G0M3f5vQj7LuJrETvjVot3Z5el9nffUtU=
 gopkg.in/yaml.v2 v2.3.0/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
+gopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=
+gopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=
 gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
 gopkg.in/yaml.v3 v3.0.0-20200615113413-eeeca48fe776 h1:tQIYjPdBoyREyB9XMu+nnTclpTYkz2zFM+lzLJFO4gQ=
 gopkg.in/yaml.v3 v3.0.0-20200615113413-eeeca48fe776/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
diff --git a/hack/restore.sh b/hack/restore.sh
new file mode 100644
index 0000000..095891f
--- /dev/null
+++ b/hack/restore.sh
@@ -0,0 +1,30 @@
+# do not has RESTORE_FROM env variable
+if [ -z "$RESTORE_FROM" ]; then
+    echo "nothing to do"
+	exit 0
+fi
+if [ -z "$S3_ENDPOINT" ] || [ -z "$S3_ACCESSKEY"] || [ -z "$S3_SECRETKEY"] || [ -z "$S3_BUCKET"] ; then
+	echo "nothing to do "
+    exit 0
+fi
+if [ ! -d "/var/lib/mysql"] ; then
+    echo "is not exist the var lib mysql"
+    mkdir /var/lib/mysql
+    chown -R mysql.mysql /var/lib/mysql
+fi
+mkdir /root/backup
+xbcloud get --storage=S3 \
+--s3-endpoint="${S3_ENDPOINT}" \
+--s3-access-key="${S3_ACCESSKEY}" \
+--s3-secret-key="${S3_SECRETKEY}" \
+--s3-bucket="${S3_BUCKET}" \
+--parallel=10 $RESTORE_FROM \
+--insecure |xbstream -xv -C /root/backup
+# prepare redolog
+xtrabackup --defaults-file=/etc/mysql/my.cnf --use-memory=3072M --prepare --apply-log-only --target-dir=/root/backup
+# prepare data
+xtrabackup --defaults-file=/etc/mysql/my.cnf --use-memory=3072M --prepare --target-dir=/root/backup
+chown -R mysql.mysql /root/backup
+xtrabackup --defaults-file=/etc/mysql/my.cnf --datadir=/var/lib/mysql --copy-back --target-dir=/root/backup
+chown -R mysql.mysql /var/lib/mysql
+rm -rf /root/backup
\ No newline at end of file
diff --git a/mysqlbackup/mysqlbackup.go b/mysqlbackup/mysqlbackup.go
new file mode 100644
index 0000000..b99e6e4
--- /dev/null
+++ b/mysqlbackup/mysqlbackup.go
@@ -0,0 +1,38 @@
+package mysqlbackup
+
+import (
+	"fmt"
+
+	v1alhpa1 "github.com/radondb/radondb-mysql-kubernetes/api/v1alpha1"
+	"github.com/radondb/radondb-mysql-kubernetes/utils"
+	logf "sigs.k8s.io/controller-runtime/pkg/log"
+)
+
+var log = logf.Log.WithName("mysqlbackup")
+
+// MysqlBackup is a type wrapper over MysqlBackup that contains the Business logic
+type MysqlBackup struct {
+	*v1alhpa1.MysqlBackup
+}
+
+// New returns a wraper object over MysqlBackup
+func New(backup *v1alhpa1.MysqlBackup) *MysqlBackup {
+	return &MysqlBackup{
+		MysqlBackup: backup,
+	}
+}
+
+// Unwrap returns the api mysqlbackup object
+func (b *MysqlBackup) Unwrap() *v1alhpa1.MysqlBackup {
+	return b.MysqlBackup
+}
+
+// GetNameForJob returns the name of the job
+func (b *MysqlBackup) GetNameForJob() string {
+	return fmt.Sprintf("%s-backup", b.Name)
+}
+
+func (b *MysqlBackup) GetBackupURL(cluster_name string, hostname string) string {
+	return fmt.Sprintf("%s.%s-mysql.%s:%v", hostname, cluster_name, b.Namespace, utils.XBackupPort)
+
+}
diff --git a/mysqlbackup/status.go b/mysqlbackup/status.go
new file mode 100644
index 0000000..3b5f92e
--- /dev/null
+++ b/mysqlbackup/status.go
@@ -0,0 +1,72 @@
+package mysqlbackup
+
+import (
+	"fmt"
+	"time"
+
+	core "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+
+	apiv1 "github.com/radondb/radondb-mysql-kubernetes/api/v1alpha1"
+)
+
+// UpdateStatusCondition sets the condition to a status.
+// for example Ready condition to True, or False
+func (c *MysqlBackup) UpdateStatusCondition(condType apiv1.BackupConditionType,
+	status core.ConditionStatus, reason, msg string) {
+	newCondition := apiv1.BackupCondition{
+		Type:    condType,
+		Status:  status,
+		Reason:  reason,
+		Message: msg,
+	}
+
+	t := time.Now()
+
+	if len(c.Status.Conditions) == 0 {
+		log.V(4).Info(fmt.Sprintf("Setting lastTransitionTime for mysql backup "+
+			"%q condition %q to %v", c.Name, condType, t))
+		newCondition.LastTransitionTime = metav1.NewTime(t)
+		c.Status.Conditions = []apiv1.BackupCondition{newCondition}
+	} else {
+		if i, exist := c.condExists(condType); exist {
+			cond := c.Status.Conditions[i]
+			if cond.Status != newCondition.Status {
+				log.V(3).Info(fmt.Sprintf("Found status change for mysql backup "+
+					"%q condition %q: %q -> %q; setting lastTransitionTime to %v",
+					c.Name, condType, cond.Status, status, t))
+				newCondition.LastTransitionTime = metav1.NewTime(t)
+			} else {
+				newCondition.LastTransitionTime = cond.LastTransitionTime
+			}
+			log.V(4).Info(fmt.Sprintf("Setting lastTransitionTime for mysql backup "+
+				"%q condition %q to %q", c.Name, condType, status))
+			c.Status.Conditions[i] = newCondition
+		} else {
+			log.V(4).Info(fmt.Sprintf("Setting new condition for mysql backup %q, condition %q to %q",
+				c.Name, condType, status))
+			newCondition.LastTransitionTime = metav1.NewTime(t)
+			c.Status.Conditions = append(c.Status.Conditions, newCondition)
+		}
+	}
+}
+
+func (c *MysqlBackup) condExists(ty apiv1.BackupConditionType) (int, bool) {
+	for i, cond := range c.Status.Conditions {
+		if cond.Type == ty {
+			return i, true
+		}
+	}
+
+	return 0, false
+}
+
+// GetBackupCondition returns a pointer to the condition of the provided type
+func (c *MysqlBackup) GetBackupCondition(condType apiv1.BackupConditionType) *apiv1.BackupCondition {
+	i, found := c.condExists(condType)
+	if found {
+		return &c.Status.Conditions[i]
+	}
+
+	return nil
+}
diff --git a/mysqlbackup/syncer/job.go b/mysqlbackup/syncer/job.go
new file mode 100644
index 0000000..5086f69
--- /dev/null
+++ b/mysqlbackup/syncer/job.go
@@ -0,0 +1,125 @@
+package syncer
+
+import (
+	"fmt"
+
+	"github.com/presslabs/controller-util/syncer"
+	apiv1 "github.com/radondb/radondb-mysql-kubernetes/api/v1alpha1"
+	"github.com/radondb/radondb-mysql-kubernetes/mysqlbackup"
+	"github.com/radondb/radondb-mysql-kubernetes/utils"
+	batch "k8s.io/api/batch/v1"
+	corev1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+	"sigs.k8s.io/controller-runtime/pkg/client"
+	logf "sigs.k8s.io/controller-runtime/pkg/log"
+)
+
+var log = logf.Log.WithName("mysqlbackup.syncer.job")
+
+//TODO: sync job
+type jobSyncer struct {
+	job    *batch.Job
+	backup *mysqlbackup.MysqlBackup
+}
+
+// NewJobSyncer returns a syncer for backup jobs
+func NewJobSyncer(c client.Client, s *runtime.Scheme, backup *mysqlbackup.MysqlBackup) syncer.Interface {
+	obj := &batch.Job{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:      backup.GetNameForJob(),
+			Namespace: backup.Namespace,
+		},
+	}
+
+	sync := &jobSyncer{
+		job:    obj,
+		backup: backup,
+	}
+
+	return syncer.NewObjectSyncer("Job", backup.Unwrap(), obj, c, sync.SyncFn)
+}
+func (s *jobSyncer) SyncFn() error {
+	if s.backup.Status.Completed {
+		log.V(1).Info("backup already completed", "backup", s.backup)
+		// skip doing anything
+		return syncer.ErrIgnore
+	}
+
+	// check if job is already created an just update the status
+	if !s.job.ObjectMeta.CreationTimestamp.IsZero() {
+		s.updateStatus(s.job)
+		return nil
+	}
+
+	s.job.Labels = map[string]string{
+		"Host": s.backup.Spec.HostName,
+	}
+
+	s.job.Spec.Template.Spec = s.ensurePodSpec(s.job.Spec.Template.Spec)
+	return nil
+}
+func (s *jobSyncer) updateStatus(job *batch.Job) {
+	// check for completion condition
+	if cond := jobCondition(batch.JobComplete, job); cond != nil {
+		s.backup.UpdateStatusCondition(apiv1.BackupComplete, cond.Status, cond.Reason, cond.Message)
+
+		if cond.Status == corev1.ConditionTrue {
+			s.backup.Status.Completed = true
+		}
+	}
+
+	// check for failed condition
+	if cond := jobCondition(batch.JobFailed, job); cond != nil {
+		s.backup.UpdateStatusCondition(apiv1.BackupFailed, cond.Status, cond.Reason, cond.Message)
+
+		if cond.Status == corev1.ConditionTrue {
+			s.backup.Status.Completed = true
+		}
+	}
+}
+
+func jobCondition(condType batch.JobConditionType, job *batch.Job) *batch.JobCondition {
+	for _, c := range job.Status.Conditions {
+		if c.Type == condType {
+			return &c
+		}
+	}
+
+	return nil
+}
+func (s *jobSyncer) ensurePodSpec(in corev1.PodSpec) corev1.PodSpec {
+	if len(in.Containers) == 0 {
+		in.Containers = make([]corev1.Container, 1)
+	}
+
+	in.RestartPolicy = corev1.RestartPolicyNever
+	// in.ImagePullSecrets = []corev1.LocalObjectReference{
+	// 	{Name: s.opt.ImagePullSecretName},
+	// }
+
+	in.Containers[0].Name = "backup"
+	in.Containers[0].Image = utils.SideCarImage
+	//in.Containers[0].ImagePullPolicy = s.opt.ImagePullPolicy
+	in.Containers[0].Args = []string{
+		"request_a_backup",
+		s.backup.GetBackupURL(s.backup.Spec.ClusterName, s.backup.Spec.HostName),
+	}
+
+	in.Containers[0].Env = []corev1.EnvVar{
+		{
+			Name:  "NAMESPACE",
+			Value: s.backup.Namespace,
+		},
+		{
+			Name:  "SERVICE_NAME",
+			Value: fmt.Sprintf("%s-mysql", s.backup.Spec.ClusterName),
+		},
+		{
+			Name: "HOST_NAME",
+
+			Value: s.backup.Spec.HostName,
+		},
+	}
+	return in
+}
diff --git a/sidecar/config.go b/sidecar/config.go
index b8b5833..5b6208c 100644
--- a/sidecar/config.go
+++ b/sidecar/config.go
@@ -17,7 +17,10 @@ limitations under the License.
 package sidecar
 
 import (
+	"fmt"
 	"strconv"
+	"strings"
+	"time"
 
 	"github.com/blang/semver"
 	"github.com/go-ini/ini"
@@ -62,6 +65,28 @@ type Config struct {
 	AdmitDefeatHearbeatCount int32
 	// The parameter in xenon means election timeout(ms)
 	ElectionTimeout int32
+	//for mysql backup
+	// backup user and password for http endpoint
+	ClusterName    string
+	BackupUser     string
+	BackupPassword string
+	// XbstreamExtraArgs is a list of extra command line arguments to pass to xbstream.
+	XbstreamExtraArgs []string
+
+	// XtrabackupExtraArgs is a list of extra command line arguments to pass to xtrabackup.
+	XtrabackupExtraArgs []string
+
+	// XtrabackupPrepareExtraArgs is a list of extra command line arguments to pass to xtrabackup
+	// during --prepare.
+	XtrabackupPrepareExtraArgs []string
+
+	// XtrabackupTargetDir is a backup destination directory for xtrabackup.
+	XtrabackupTargetDir string
+	XCloudS3EndPoint    string
+	XCloudS3AccessKey   string
+	XCloudS3SecretKey   string
+	XCloudS3Bucket      string
+	XRestoreFrom        string
 }
 
 // NewConfig returns a pointer to Config.
@@ -108,7 +133,58 @@ func NewConfig() *Config {
 
 		AdmitDefeatHearbeatCount: int32(admitDefeatHearbeatCount),
 		ElectionTimeout:          int32(electionTimeout),
+
+		ClusterName:                getEnvValue("SERVICE_NAME"),
+		BackupUser:                 "sys_backups", //getEnvValue("BACKUP_USER"),
+		BackupPassword:             "sys_backups", //getEnvValue("BACKUP_PASSWORD"),
+		XbstreamExtraArgs:          strings.Fields(getEnvValue("XBSTREAM_EXTRA_ARGS")),
+		XtrabackupExtraArgs:        strings.Fields(getEnvValue("XTRABACKUP_EXTRA_ARGS")),
+		XtrabackupPrepareExtraArgs: strings.Fields(getEnvValue("XTRABACKUP_PREPARE_EXTRA_ARGS")),
+		XtrabackupTargetDir:        getEnvValue("XTRABACKUP_TARGET_DIR"),
+		//TODO
+		XCloudS3EndPoint:  getEnvValue("S3_ENDPOINT"),
+		XCloudS3AccessKey: getEnvValue("S3_ACCESSKEY"),
+		XCloudS3SecretKey: getEnvValue("S3_SECRETKEY"),
+		XCloudS3Bucket:    getEnvValue("S3_BUCKET"),
+		XRestoreFrom:      getEnvValue("RESTORE_FROM"),
+	}
+}
+func (cfg *Config) XtrabackupArgs() []string {
+	// xtrabackup --backup <args> --target-dir=<backup-dir> <extra-args>
+	user := "root"
+	if len(cfg.ReplicationUser) != 0 {
+		user = cfg.ReplicationUser
+	}
+
+	tmpdir := "/root/backup/"
+	if len(cfg.XtrabackupTargetDir) != 0 {
+		tmpdir = cfg.XtrabackupTargetDir
+	}
+	xtrabackupArgs := []string{
+		"--backup",
+		"--stream=xbstream",
+		"--host=127.0.0.1",
+		fmt.Sprintf("--user=%s", user),
+		fmt.Sprintf("--target-dir=%s", tmpdir),
+	}
+
+	return append(xtrabackupArgs, cfg.XtrabackupExtraArgs...)
+}
+func (cfg *Config) XCloudArgs() []string {
+	cur_time := time.Now()
+	xcloudArgs := []string{
+		"put",
+		"--storage=S3",
+		fmt.Sprintf("--s3-endpoint=%s", cfg.XCloudS3EndPoint),
+		fmt.Sprintf("--s3-access-key=%s", cfg.XCloudS3AccessKey),
+		fmt.Sprintf("--s3-secret-key=%s", cfg.XCloudS3SecretKey),
+		fmt.Sprintf("--s3-bucket=%s", cfg.XCloudS3Bucket),
+		"--parallel=10",
+		fmt.Sprintf("backup_%v%v%v%v%v%v", cur_time.Year(), int(cur_time.Month()),
+			cur_time.Day(), cur_time.Hour(), cur_time.Minute(), cur_time.Second()),
+		"--insecure",
 	}
+	return xcloudArgs
 }
 
 // buildExtraConfig build a ini file for mysql.
diff --git a/sidecar/init.go b/sidecar/init.go
index c451396..23d6cad 100644
--- a/sidecar/init.go
+++ b/sidecar/init.go
@@ -140,6 +140,14 @@ func runInitCommand(cfg *Config) error {
 	if err = ioutil.WriteFile(xenonFilePath, buildXenonConf(cfg), 0644); err != nil {
 		return fmt.Errorf("failed to write xenon.json: %s", err)
 	}
+	//add the init sql
+	if len(cfg.XRestoreFrom) != 0 {
+		cmd := exec.Command("sh", "-c", "/restore.sh")
+		cmd.Stderr = os.Stderr
+		if err = cmd.Run(); err != nil {
+			return fmt.Errorf("failed to disable the run restore: %s", err)
+		}
+	}
 
 	log.Info("init command success")
 	return nil
@@ -246,3 +254,15 @@ FLUSH PRIVILEGES;
 
 	return utils.StringToBytes(sql)
 }
+
+/*start the backup http server*/
+func RunHttpServer(cfg *Config, stop <-chan struct{}) error {
+	srv := newServer(cfg, stop)
+	return srv.ListenAndServe()
+}
+
+/*request a backup command*/
+func RunRequestBackup(cfg *Config, host string) error {
+	_, err := requestABackup(cfg, host, serverBackupEndpoint)
+	return err
+}
diff --git a/sidecar/server.go b/sidecar/server.go
new file mode 100644
index 0000000..fa5b350
--- /dev/null
+++ b/sidecar/server.go
@@ -0,0 +1,160 @@
+package sidecar
+
+import (
+	"context"
+	"fmt"
+	"net"
+	"net/http"
+	"strings"
+	"time"
+
+	"github.com/radondb/radondb-mysql-kubernetes/utils"
+)
+
+const (
+	backupStatusTrailer  = "X-Backup-Status"
+	backupSuccessful     = "Success"
+	backupFailed         = "Failed"
+	serverPort           = utils.XBackupPort
+	serverProbeEndpoint  = "/health"
+	serverBackupEndpoint = "/xbackup"
+	serverConnectTimeout = 5 * time.Second
+)
+
+type server struct {
+	cfg *Config
+	http.Server
+}
+
+func newServer(cfg *Config, stop <-chan struct{}) *server {
+	mux := http.NewServeMux()
+	srv := &server{
+		cfg: cfg,
+		Server: http.Server{
+			Addr:    fmt.Sprintf(":%d", serverPort),
+			Handler: mux,
+		},
+	}
+
+	// Add handle functions
+	mux.HandleFunc(serverProbeEndpoint, srv.healthHandler)
+	mux.Handle(serverBackupEndpoint, maxClients(http.HandlerFunc(srv.backupHandler), 1))
+
+	// Shutdown gracefully the http server
+	go func() {
+		<-stop // wait for stop signal
+		if err := srv.Shutdown(context.Background()); err != nil {
+			log.Error(err, "failed to stop http server")
+
+		}
+	}()
+
+	return srv
+}
+
+// nolint: unparam
+func (s *server) healthHandler(w http.ResponseWriter, r *http.Request) {
+	w.WriteHeader(http.StatusOK)
+	if _, err := w.Write([]byte("OK")); err != nil {
+		log.Error(err, "failed writing request")
+	}
+}
+
+func (s *server) backupHandler(w http.ResponseWriter, r *http.Request) {
+
+	w.Header().Set("Connection", "keep-alive")
+	if !s.isAuthenticated(r) {
+		http.Error(w, "Not authenticated!", http.StatusForbidden)
+		return
+	}
+	err := RunTakeBackupCommand(s.cfg, "hello")
+	if err != nil {
+		http.Error(w, err.Error(), http.StatusInternalServerError)
+	} else {
+		w.Write([]byte("OK"))
+	}
+}
+
+func (s *server) isAuthenticated(r *http.Request) bool {
+	user, pass, ok := r.BasicAuth()
+	return ok && user == s.cfg.BackupUser && pass == s.cfg.BackupPassword
+}
+
+// maxClients limit an http endpoint to allow just n max concurrent connections
+func maxClients(h http.Handler, n int) http.Handler {
+	sema := make(chan struct{}, n)
+
+	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		sema <- struct{}{}
+		defer func() { <-sema }()
+
+		h.ServeHTTP(w, r)
+	})
+}
+
+func prepareURL(svc string, endpoint string) string {
+	if !strings.Contains(svc, ":") {
+		svc = fmt.Sprintf("%s:%d", svc, serverPort)
+	}
+	return fmt.Sprintf("http://%s%s", svc, endpoint)
+}
+
+func transportWithTimeout(connectTimeout time.Duration) http.RoundTripper {
+	return &http.Transport{
+		Proxy: http.ProxyFromEnvironment,
+		DialContext: (&net.Dialer{
+			Timeout:   connectTimeout,
+			KeepAlive: 30 * time.Second,
+			DualStack: true,
+		}).DialContext,
+		MaxIdleConns:          100,
+		IdleConnTimeout:       90 * time.Second,
+		TLSHandshakeTimeout:   10 * time.Second,
+		ExpectContinueTimeout: 1 * time.Second,
+	}
+}
+
+// requestABackup connects to specified host and endpoint and gets the backup
+func requestABackup(cfg *Config, host string, endpoint string) (*http.Response, error) {
+	log.Info("initialize a backup", "host", host, "endpoint", endpoint)
+
+	req, err := http.NewRequest("GET", prepareURL(host, endpoint), nil)
+	if err != nil {
+		return nil, fmt.Errorf("fail to create request: %s", err)
+	}
+
+	// set authentication user and password
+	req.SetBasicAuth(cfg.BackupUser, cfg.BackupPassword)
+
+	client := &http.Client{}
+	client.Transport = transportWithTimeout(serverConnectTimeout)
+
+	resp, err := client.Do(req)
+	if err != nil || resp.StatusCode != 200 {
+		status := "unknown"
+		if resp != nil {
+			status = resp.Status
+		}
+		return nil, fmt.Errorf("fail to get backup: %s, code: %s", err, status)
+	}
+
+	return resp, nil
+}
+
+func checkBackupTrailers(resp *http.Response) error {
+	if values, ok := resp.Trailer[backupStatusTrailer]; !ok || !stringInSlice(backupSuccessful, values) {
+		// backup is failed, remove from remote
+		return fmt.Errorf("backup failed to be taken: no 'Success' trailer found")
+	}
+
+	return nil
+}
+
+func stringInSlice(a string, list []string) bool {
+	for _, b := range list {
+		if b == a {
+			return true
+		}
+	}
+	return false
+}
diff --git a/sidecar/takebackup.go b/sidecar/takebackup.go
new file mode 100644
index 0000000..9ce1fa8
--- /dev/null
+++ b/sidecar/takebackup.go
@@ -0,0 +1,48 @@
+package sidecar
+
+import (
+	"os"
+	"os/exec"
+	"strings"
+)
+
+// RunTakeBackupCommand starts a backup command
+func RunTakeBackupCommand(cfg *Config, name string) error {
+	log.Info("backup mysql", "name", name)
+	// cfg->XtrabackupArgs()
+	xtrabackup := exec.Command(xtrabackupCommand, cfg.XtrabackupArgs()...)
+
+	var err error
+
+	xcloud := exec.Command(xcloudCommand, cfg.XCloudArgs()...)
+	log.Info("xargs ", "xargs", strings.Join(cfg.XCloudArgs(), " "))
+	if xcloud.Stdin, err = xtrabackup.StdoutPipe(); err != nil {
+		log.Error(err, "failed to pipline")
+		return err
+	}
+	xtrabackup.Stderr = os.Stderr
+	xcloud.Stderr = os.Stderr
+
+	if err := xtrabackup.Start(); err != nil {
+		log.Error(err, "failed to start xtrabackup command")
+
+		return err
+	}
+	if err := xcloud.Start(); err != nil {
+		log.Error(err, "fail start xcloud ")
+		return err
+	}
+	// copy stardout to xcloud
+	if err := xtrabackup.Wait(); err != nil {
+		log.Error(err, "failed waiting for xtrabackup to finish")
+
+		return err
+	}
+	if err := xcloud.Wait(); err != nil {
+		log.Error(err, "failed waiting for xcloud to finish")
+
+		return err
+	}
+
+	return nil
+}
diff --git a/sidecar/util.go b/sidecar/util.go
index d7995cc..f99a19c 100644
--- a/sidecar/util.go
+++ b/sidecar/util.go
@@ -56,7 +56,9 @@ var (
 	xenonPath = utils.XenonVolumeMountPath
 
 	// initFilePath is the init files path for mysql.
-	initFilePath = utils.InitFileVolumeMountPath
+	initFilePath      = utils.InitFileVolumeMountPath
+	xtrabackupCommand = "xtrabackup"
+	xcloudCommand     = "xbcloud"
 )
 
 // copyFile the src file to dst.
diff --git a/utils/constants.go b/utils/constants.go
index 3e2b3b3..afdb5dc 100644
--- a/utils/constants.go
+++ b/utils/constants.go
@@ -42,7 +42,10 @@ const (
 	ContainerMetricsName  = "metrics"
 	ContainerSlowLogName  = "slowlog"
 	ContainerAuditLogName = "auditlog"
+	ContainerBackupName   = "backup"
 
+	XBackupPortName = "xtrabackup"
+	XBackupPort     = 8082
 	// MySQL port.
 	MysqlPortName = "mysql"
 	MysqlPort     = 3306
@@ -82,6 +85,7 @@ const (
 	ScriptsVolumeMountPath  = "/scripts"
 	XenonVolumeMountPath    = "/etc/xenon"
 	InitFileVolumeMountPath = "/docker-entrypoint-initdb.d"
+	SideCarImage            = "acekingke/sidecar:v01"
 )
 
 // ResourceName is the type for aliasing resources that will be created.
@@ -99,7 +103,8 @@ const (
 	// FollowerService is the name of a service that points healthy followers (excludes leader).
 	FollowerService ResourceName = "follower-service"
 	// Secret is the name of the secret that contains operator related credentials.
-	Secret ResourceName = "secret"
+	Secret       ResourceName = "secret"
+	BackupSecret ResourceName = "backup-secret"
 	// Role is the alias of the role resource.
 	Role ResourceName = "role"
 	// RoleBinding is the alias of the rolebinding resource.
